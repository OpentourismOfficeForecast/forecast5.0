---
title: "Zeitreihenanalysen Lenzerheide"
date: "November 2019"
author:
- Ramon Schildknecht
output:
  html_document:
    df_print: paged
    theme: united
    toc: yes
    number_sections: true
    toc_float: true
  pdf_document: default
---

<br>


# Abstract
## Ausgangslage
tbd

## Fragestellung
tbd

## Ergebnisse
tbd

<br><br>

## Libraries laden

```{r message=FALSE, warning=FALSE}
# load libraries

library(getPass)
library(RCurl)
library(tidyverse)
library(magrittr)
library(janitor)
library(readxl)
library(lubridate)
library(DataExplorer)
library(ggfortify)  # autoplot
library(vistime)
library(plotly)
library(DT)
library(summarytools)
library(DT) # for dynamic tables
library(wordcloud) # to render wordclouds
library(tidytext) # for NLP
library(tm)  # for text mining
library(dygraphs)  # nice time series visualization
library(xts)  # more efficient time series format
```

<br><br>


# Bewertung der Datenlage

## Daten Laden

**Hauptdaten**


```{r}
# load & preprocess data

d <- read_csv("./dataset_lenzerheide.csv")

# lower case all variable names for easier programming
d %<>% rename_all(tolower)

d$datum <- dmy(d$datum)

d %<>%
  filter(datum < "2019-10-01")%>%
  arrange(desc(datum))

d %<>% filter(datum < "2016-05-01" | datum > "2017-04-30")
write_csv(d, "./lenzerheide_zeiraeume_ohne_leere_labels.csv")  # for future ...
# ... working with Python for everybody in this project

introduce(d)
plot_intro(d)
plot_missing(d)
plot_correlation(d)
plot_histogram(d)

```


<br><br>


# Zeitreihe analysieren

## Schalter

```{r warning=TRUE}
d_schalter <- d %>% select(datum, schalter)

# show first plot
plot(d_schalter, type = "l")  # base R
```


<br><br>



### Vergleich auf Tagesbasis

```{r}
# create time series

(d_schalter_ts <- ts(d_schalter[,-1], start = c(2016,1),  end = c(2019, 9), frequency = 365))  # static plot

autoplot(d_schalter_ts)  # improved graph

# decompose
d_schalter_decompose <- decompose(d_schalter_ts)  # base R
plot(d_schalter_decompose)  # base R


# sesonality
plot(as.ts(d_schalter_decompose$seasonal))
 
# trend
plot(as.ts(d_schalter_decompose$trend))

# remainder
plot(as.ts(d_schalter_decompose$random))

# perform loess decomposition as well

d_schalter_stl <- stl(d_schalter_ts, s.window = "periodic")
plot(d_schalter_stl)  # base R
autoplot(d_schalter_stl)
# seasonality

(d_schalter_stl_season <- d_schalter_stl$time.series[, 1])

# trend
(d_schalter_stl_trend <- d_schalter_stl$time.series[, 2])

# remainder
(d_schalter_stl_remainder <- d_schalter_stl$time.series[, 3])
```


### Vergleich decompose() und stl() Dekompositionen

```{r warning=FALSE}
plot(d_schalter_decompose)  # base R
(result_day <- autoplot(d_schalter_stl, title = "Daily Decomposition"))

# one would continue to use stl because the decompose() function has two disadvantages:
## 1. The estimate of the trend is unavailable for the first few and last few observations.
## 2. It assumes that the seasonal component repeats from year to year.
## further advantages for stl -> https://stats.stackexchange.com/questions/85987/which-is-better-stl-or-decompose
```



<br><br>


### Resultate verdichtet

```{r message=FALSE, warning=FALSE}
d_schalter_daily_xts <- xts(x = d$schalter, order.by = d$datum)
names(d_schalter_daily_xts) <- "schalter"

d_schalter_daily_monthly_xts <- apply.monthly(d_schalter_daily_xts, sum)

dygraph(d_schalter_daily_xts)

# interactive graph
dygraph(d_schalter_daily_xts, main = "Daily aggregated line plot") %>%
  dyRangeSelector()


```


<br><br>








## Telefon

```{r warning=TRUE}
d_telefon <- d %>% select(datum, tel)
plot_missing(d_telefon)
d_telefon <- na.omit(d_telefon)  # remove 3% of data with NAs

# show first plot
plot(d_telefon, type = "l")  # base R
```


<br><br>



### Vergleich auf Tagesbasis

```{r}
# create time series

(d_telefon_ts <- ts(d_telefon[,-1], start = c(2016,1),  end = c(2019, 9), frequency = 365))  # static plot

autoplot(d_telefon_ts)  # improved graph

# decompose
d_telefon_decompose <- decompose(d_telefon_ts)  # base R
plot(d_telefon_decompose)  # base R


# sesonality
plot(as.ts(d_telefon_decompose$seasonal))
 
# trend
plot(as.ts(d_telefon_decompose$trend))

# remainder
plot(as.ts(d_telefon_decompose$random))

# perform loess decomposition as well

d_telefon_stl <- stl(d_telefon_ts, s.window = "periodic")
plot(d_telefon_stl)  # base R
autoplot(d_telefon_stl)
# seasonality

(d_telefon_stl_season <- d_telefon_stl$time.series[, 1])

# trend
(d_telefon_stl_trend <- d_telefon_stl$time.series[, 2])

# remainder
(d_telefon_stl_remainder <- d_telefon_stl$time.series[, 3])
```


### Vergleich decompose() und stl() Dekompositionen

```{r warning=FALSE}
plot(d_telefon_decompose)  # base R
(result_day <- autoplot(d_telefon_stl, title = "Daily Decomposition"))

# one would continue to use stl because the decompose() function has two disadvantages:
## 1. The estimate of the trend is unavailable for the first few and last few observations.
## 2. It assumes that the seasonal component repeats from year to year.
## further advantages for stl -> https://stats.stackexchange.com/questions/85987/which-is-better-stl-or-decompose
```



<br><br>


### Resultate verdichtet

```{r message=FALSE, warning=FALSE}
d_telefon_daily_xts <- xts(x = d$schalter, order.by = d$datum)
names(d_telefon_daily_xts) <- "schalter"

d_telefon_daily_monthly_xts <- apply.monthly(d_telefon_daily_xts, sum)

dygraph(d_telefon_daily_xts)


```


<br><br>







## Email

```{r warning=TRUE}
d_email <- d %>% select(datum, schalter)

# show first plot
plot(d_email, type = "l")  # base R
```


<br><br>



### Vergleich auf Tagesbasis

```{r}
# create time series

(d_email_ts <- ts(d_email[,-1], start = c(2016,1),  end = c(2019, 9), frequency = 365))  # static plot

autoplot(d_email_ts)  # improved graph

# decompose
d_email_decompose <- decompose(d_email_ts)  # base R
plot(d_email_decompose)  # base R


# sesonality
plot(as.ts(d_email_decompose$seasonal))
 
# trend
plot(as.ts(d_email_decompose$trend))

# remainder
plot(as.ts(d_email_decompose$random))

# perform loess decomposition as well

d_email_stl <- stl(d_email_ts, s.window = "periodic")
plot(d_email_stl)  # base R
autoplot(d_email_stl)
# seasonality

(d_email_stl_season <- d_email_stl$time.series[, 1])

# trend
(d_email_stl_trend <- d_email_stl$time.series[, 2])

# remainder
(d_email_stl_remainder <- d_email_stl$time.series[, 3])
```


### Vergleich decompose() und stl() Dekompositionen

```{r warning=FALSE}
plot(d_email_decompose)  # base R
(result_day <- autoplot(d_email_stl, title = "Daily Decomposition"))

# one would continue to use stl because the decompose() function has two disadvantages:
## 1. The estimate of the trend is unavailable for the first few and last few observations.
## 2. It assumes that the seasonal component repeats from year to year.
## further advantages for stl -> https://stats.stackexchange.com/questions/85987/which-is-better-stl-or-decompose
```



<br><br>


### Resultate verdichtet

```{r message=FALSE, warning=FALSE}
d_email_daily_xts <- xts(x = d$schalter, order.by = d$datum)
names(d_email_daily_xts) <- "schalter"

d_email_daily_monthly_xts <- apply.monthly(d_email_daily_xts, sum)

dygraph(d_email_daily_xts)

```


<br><br>



